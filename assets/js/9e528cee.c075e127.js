"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6633],{35318:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var a=n(27378);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),m=p(n),c=o,h=m["".concat(s,".").concat(c)]||m[c]||d[c]||i;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,l[1]=r;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},92510:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var a=n(25773),o=(n(27378),n(35318));const i={title:"WASM plugin (experimental)",sidebar_label:"WASM (experimental)",toc_max_heading_level:5},l=void 0,r={unversionedId:"proto/wasm-plugin",id:"proto/wasm-plugin",title:"WASM plugin (experimental)",description:"Plugins can be written in WebAssembly (WASM), a portable binary format.",source:"@site/docs/proto/wasm-plugin.mdx",sourceDirName:"proto",slug:"/proto/wasm-plugin",permalink:"/docs/proto/wasm-plugin",draft:!1,editUrl:"https://github.com/moonrepo/moon/tree/master/website/docs/proto/wasm-plugin.mdx",tags:[],version:"current",frontMatter:{title:"WASM plugin (experimental)",sidebar_label:"WASM (experimental)",toc_max_heading_level:5},sidebar:"proto",previous:{title:"TOML",permalink:"/docs/proto/toml-plugin"},next:{title:"alias",permalink:"/docs/proto/commands/alias"}},s={},p=[{value:"Concepts",id:"concepts",level:2},{value:"Virtual paths",id:"virtual-paths",level:3},{value:"Host environment",id:"host-environment",level:3},{value:"Host functions",id:"host-functions",level:3},{value:"Tool ID and context",id:"tool-id-and-context",level:3},{value:"Create a plugin",id:"create-a-plugin",level:2},{value:"Implementing plugin functions",id:"implementing-plugin-functions",level:2},{value:"Registering metadata",id:"registering-metadata",level:3},{value:"Downloading pre-builts",id:"downloading-pre-builts",level:3},{value:"Unpacking an archive",id:"unpacking-an-archive",level:4},{value:"Locating binaries",id:"locating-binaries",level:3},{value:"Loading and resolving versions",id:"loading-and-resolving-versions",level:3},{value:"Detecting versions",id:"detecting-versions",level:3},{value:"Creating shims",id:"creating-shims",level:3},{value:"Global shims",id:"global-shims",level:4},{value:"Installing and uninstalling globals",id:"installing-and-uninstalling-globals",level:3},{value:"Testing",id:"testing",level:2},{value:"Unit tests",id:"unit-tests",level:3},{value:"Testing plugin functions",id:"testing-plugin-functions",level:4},{value:"Generating cases from macros",id:"generating-cases-from-macros",level:4},{value:"Building and publishing",id:"building-and-publishing",level:2},{value:"Manually create releases",id:"manually-create-releases",level:3},{value:"Automate releases",id:"automate-releases",level:3},{value:"Resources",id:"resources",level:2}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Plugins can be written in ",(0,o.kt)("a",{parentName:"p",href:"https://webassembly.org/"},"WebAssembly (WASM)"),", a portable binary format.\nThis means that plugins can be written in any language that compiles to WASM, like Rust, C, C++, Go,\nTypeScript, and more. Because WASM based plugins are powered by a programming language, they\nimplicitly support complex business logic and behavior, have access to a sandboxed file system (via\nWASI), can execute child processes, and much more."),(0,o.kt)("admonition",{type:"danger"},(0,o.kt)("p",{parentName:"admonition"},"Since our WASM plugin implementation is still experimental, expect breaking changes to occur in\nnon-major releases.")),(0,o.kt)("h2",{id:"concepts"},"Concepts"),(0,o.kt)("p",null,"Before we begin, let's talk about a few concepts that are critical to WASM and our plugin system."),(0,o.kt)("h3",{id:"virtual-paths"},"Virtual paths"),(0,o.kt)("p",null,"WASM by default does not have access to the host file system, but through ",(0,o.kt)("a",{parentName:"p",href:"https://wasi.dev/"},"WASI"),",\nwe can provide sandboxed access to a pre-defined list of allowed directories. We call this\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/proto_pdk/latest/proto_pdk/enum.VirtualPath.html"},"virtual paths"),", and all paths\nprovided via function input or context use them."),(0,o.kt)("p",null,"Virtual paths are implemented by mapping a real path (host machine) to a virtual path (guest\nruntime) using file path prefixes. The following prefixes are currently supported:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Real path"),(0,o.kt)("th",{parentName:"tr",align:null},"Virtual path"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"~")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"/home"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"~/.proto")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"/proto"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"CWD"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"/workspace"))))),(0,o.kt)("p",null,"For example, from the context of WASM, you may have a virtual path of ",(0,o.kt)("inlineCode",{parentName:"p"},"/proto/tools/node/1.2.3"),",\nwhich simply maps back to ",(0,o.kt)("inlineCode",{parentName:"p"},"~/.proto/tools/node/1.2.3")," on the host machine. However, this should\nalmost always be transparent to you, the developer, and to end users."),(0,o.kt)("p",null,"However, there may be a few cases where you need access to the real path from WASM, for example,\nlogging or executing commands. For this, the real path can be accessed with the\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/proto_pdk/latest/proto_pdk/enum.VirtualPath.html#method.real_path"},(0,o.kt)("inlineCode",{parentName:"a"},"real_path")),"\nfunction on the ",(0,o.kt)("inlineCode",{parentName:"p"},"VirtualPath")," enum (this is a Rust only feature)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"input.tool_dir.real_path();\n")),(0,o.kt)("h3",{id:"host-environment"},"Host environment"),(0,o.kt)("p",null,"Since WASM executes in its own runtime, it ",(0,o.kt)("em",{parentName:"p"},"does not")," have access to the current host operating\nsystem, architecture, so on and so forth. To bridge this gap, we provide the\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/proto_pdk/latest/proto_pdk/fn.get_proto_environment.html"},(0,o.kt)("inlineCode",{parentName:"a"},"get_proto_environment")),"\nfunction.\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/proto_pdk/latest/proto_pdk/struct.HostEnvironment.html"},"Learn more about this type"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let env = get_proto_environment()?;\n")),(0,o.kt)("p",null,"The host operating system and architecture can be accessed with ",(0,o.kt)("inlineCode",{parentName:"p"},"os")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"arch")," fields respectively.\nBoth fields are an enum in Rust, or a string in other languages."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"if env.os == HostOS::Windows {\n    // Windows only\n}\n\nif env.arch == HostArch::Arm64 {\n    // aarch64 only\n}\n")),(0,o.kt)("p",null,"Furthermore, the user's home directory (",(0,o.kt)("inlineCode",{parentName:"p"},"~"),") and proto's root directory (",(0,o.kt)("inlineCode",{parentName:"p"},"~/.proto"),") can be accessed\nwith the ",(0,o.kt)("inlineCode",{parentName:"p"},"home_dir")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"proto_dir")," fields, both of which are ",(0,o.kt)("a",{parentName:"p",href:"#virtual-paths"},"virtual paths"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"if env.home_dir.join(some_path).exists() {\n    // Do something\n}\n")),(0,o.kt)("h3",{id:"host-functions"},"Host functions"),(0,o.kt)("p",null,"WASM is pretty powerful but it can't do everything since it's sandboxed. To work around this, we\nprovide a mechanism known as host functions, which are functions that are implemented on the host\n(in Rust), and can be executed from WASM. The following host functions are currently available:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/proto_pdk/latest/proto_pdk/macro.exec_command.html"},(0,o.kt)("inlineCode",{parentName:"a"},"exec_command"))," - Execute a\nsystem command on the host machine, with a provided list of arguments or environment variables."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/proto_pdk/latest/proto_pdk/macro.host_log.html"},(0,o.kt)("inlineCode",{parentName:"a"},"host_log"))," - Log a message to\nthe host's stderr. This acts like tracing logs, and is not a general purpose stdout logger.")),(0,o.kt)("p",null,"To use host functions, you'll need to make them available by registering them at the top of your\nRust file (only add the functions you want to use)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[host_fn]\nextern "ExtismHost" {\n    fn exec_command(input: Json<ExecCommandInput>) -> Json<ExecCommandOutput>;\n    fn host_log(input: Json<HostLogInput>);\n}\n')),(0,o.kt)("p",null,"And then calling the provided ",(0,o.kt)("inlineCode",{parentName:"p"},"exec_command!")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"host_log!")," macros. Each macro supports shorthand\nvariants, and an explicit variant that accepts the input struct."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'exec_command!("which", ["node"]);\nexec_command!(pipe, "npm", ["install"]); // Pipe stdout/stderr\nexec_command!(inherit, "npm", ["install"]); // Inherit stdout/stderr\nexec_command!(ExecCommandInput {\n    command: "npm".into(),\n    args: vec!["install".into()],\n    env_vars: HashMap::new(),\n    stream: false,\n});\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'host_log!("Some message");\nhost_log!("Some message with {}", "args");\nhost_log!(HostLogInput::Fields {\n    message: "Some message with data".into(),\n    data: HashMap::from_iter([\n        ("data".into(), serde_json::to_value(data)?),\n    ]),\n});\n')),(0,o.kt)("h3",{id:"tool-id-and-context"},"Tool ID and context"),(0,o.kt)("p",null,"When implementing plugin functions, you'll need to access information about the current tool. To get\nthe current tool ID (the key the plugin was configured with), use the\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/proto_pdk/latest/proto_pdk/fn.get_tool_id.html"},(0,o.kt)("inlineCode",{parentName:"a"},"get_tool_id"))," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let id = get_tool_id();\n")),(0,o.kt)("p",null,"Additionally, we also provide what we call the tool context, which is information that is constantly\nchanging depending on the current step or state of proto's execution. The context cannot be accessed\nwith a stand-alone function, and is instead passed as a ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," field in the input of many plugin\nfunctions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[plugin_fn]\npub fn download_prebuilt(Json(input): Json<DownloadPrebuiltInput>) -> FnResult<Json<DownloadPrebuiltOutput>> {\n    let version = input.context.version;\n    // ...\n}\n")),(0,o.kt)("p",null,"The following fields are available on the\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.rs/proto_pdk/latest/proto_pdk/struct.ToolContext.html"},"context object"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"env_vars")," - A map of environment variables requested by the\n",(0,o.kt)("a",{parentName:"li",href:"#registering-metadata"},(0,o.kt)("inlineCode",{parentName:"a"},"register_tool"))," function."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tool_dir")," - A virtual path to the tool's directory for the current version."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"version"),' - The current version. If not resolved, will be "latest".')),(0,o.kt)("h2",{id:"create-a-plugin"},"Create a plugin"),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Although plugins can be written in any language that compiles to WASM, we've only tested Rust. The\nrest of this article assume you're using Rust and Cargo! Refer to ",(0,o.kt)("a",{parentName:"p",href:"https://extism.org/"},"Extism"),"'s\ndocumentation or our official ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/moonrepo/node-plugin"},"Node.js plugin")," for other\nexamples.")),(0,o.kt)("p",null,"To start, create a new crate with Cargo:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"cargo new plugin --lib\ncd plugin\n")),(0,o.kt)("p",null,"And set the lib type to ",(0,o.kt)("inlineCode",{parentName:"p"},"cdylib"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml",metastring:'title="Cargo.toml"',title:'"Cargo.toml"'},"[lib]\ncrate-type = ['cdylib']\n")),(0,o.kt)("p",null,"Our Rust plugins are powered by ",(0,o.kt)("a",{parentName:"p",href:"https://extism.org/"},"Extism"),", so lets add their PDK and ours as a\ndependency."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"cargo add extism-pdk proto_pdk\n")),(0,o.kt)("p",null,"In all Rust files, we can import both PDKs with the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},"use extism_pdk::*;\nuse proto_pdk::*;\n")),(0,o.kt)("p",null,"We can then build the WASM binary. The file will be available at\n",(0,o.kt)("inlineCode",{parentName:"p"},"target/wasm32-wasi/debug/<name>.wasm"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"cargo install cargo-wasi\ncargo wasi build\n")),(0,o.kt)("h2",{id:"implementing-plugin-functions"},"Implementing plugin functions"),(0,o.kt)("p",null,"Plugins are powered by a set of functions that are called from the host, and are annotated with\n",(0,o.kt)("inlineCode",{parentName:"p"},"#[plugin_fn]"),"."),(0,o.kt)("h3",{id:"registering-metadata"},"Registering metadata"),(0,o.kt)("p",null,"The first step in a plugin's life-cycle is to register metadata about the plugin with the\n",(0,o.kt)("inlineCode",{parentName:"p"},"register_tool")," function. This function is called immediately after a plugin is loaded at runtime,\nand must return a human-readable name and plugin type."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn register_tool(_: ()) -> FnResult<Json<ToolMetadataOutput>> {\n    Ok(Json(ToolMetadataOutput {\n        name: "Node.js".into(),\n        type_of: PluginType::Language,\n        plugin_version: Some(env!("CARGO_PKG_VERSION").into()),\n        ..ToolMetadataOutput::default()\n    }))\n}\n')),(0,o.kt)("p",null,"This function also receives the plugin ID as input, allowing for conditional logic based on the ID.\nThe ID is the ",(0,o.kt)("a",{parentName:"p",href:"#enabling-plugins"},"key the plugin was configured with"),", and what is passed to ",(0,o.kt)("inlineCode",{parentName:"p"},"proto"),"\ncommands (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"proto install <id>"),")."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[plugin_fn]\npub fn register_tool(Json(input): Json<ToolMetadataInput>) -> FnResult<Json<ToolMetadataOutput>> {\n  input.id\n  // ...\n}\n")),(0,o.kt)("h3",{id:"downloading-pre-builts"},"Downloading pre-builts"),(0,o.kt)("p",null,"Our plugin layer ",(0,o.kt)("em",{parentName:"p"},"only")," supports downloading pre-built tools, typically as an archive, and does\n",(0,o.kt)("em",{parentName:"p"},"not")," support building from source. The ",(0,o.kt)("inlineCode",{parentName:"p"},"download_prebuilt")," function ",(0,o.kt)("em",{parentName:"p"},"must")," be defined, whichs\nconfigures how the tool should be downloaded and installed."),(0,o.kt)("p",null,"The following fields are available:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"archive_prefix")," - If the tool is distributed as an archive (zip, tar, etc), this is the name of\nthe direct folder within the archive that contains the tool, and will be removed when unpacking\nthe archive. If there is no prefix folder within the archive, this setting can be omitted."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"download_url")," (required) - A secure URL to download the tool/archive."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"download_name")," - File name of the archive to download. If not provided, will attempt to extract\nit from the URL."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"checksum_url")," - A secure URL to download the checksum file for verification. If the tool does not\nsupport checksum verification, this setting can be omitted.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn download_prebuilt(Json(input): Json<DownloadPrebuiltInput>) -> FnResult<Json<DownloadPrebuiltOutput>> {\n     let env = get_proto_environment()?;\n\n    check_supported_os_and_arch(\n        NAME,\n        &env,\n        permutations! [\n            HostOS::Linux => [HostArch::X64, HostArch::Arm64, HostArch::Arm, HostArch::Powerpc64, HostArch::S390x],\n            HostOS::MacOS => [HostArch::X64, HostArch::Arm64],\n            HostOS::Windows => [HostArch::X64, HostArch::X86, HostArch::Arm64],\n        ],\n    )?;\n\n    let version = input.context.version;\n    let arch = env.arch;\n    let os = env.os;\n\n    let prefix = match os {\n        HostOS::Linux => format!("node-v{version}-linux-{arch}"),\n        HostOS::MacOS => format!("node-v{version}-darwin-{arch}"),\n        HostOS::Windows => format!("node-v{version}-win-{arch}"),\n        other => {\n            return Err(PluginError::UnsupportedPlatform("Node.js".into(), other.into()))?;\n        }\n    };\n\n    let filename = if os == HostOS::Windows {\n        format!("{prefix}.zip")\n    } else {\n        format!("{prefix}.tar.xz")\n    };\n\n    Ok(Json(DownloadPrebuiltOutput {\n        archive_prefix: Some(prefix),\n        download_url: format!("https://nodejs.org/dist/v{version}/{filename}"),\n        download_name: Some(filename),\n        checksum_url: Some(format!("https://nodejs.org/dist/v{version}/SHASUMS256.txt")),\n        ..DownloadPrebuiltOutput::default()\n    }))\n}\n')),(0,o.kt)("h4",{id:"unpacking-an-archive"},"Unpacking an archive"),(0,o.kt)("p",null,"Our plugin layer will do its best to detect file extensions, unpack the downloaded file (if an\narchive), and install the tool to the correct directory. However, we're unable to account for ",(0,o.kt)("em",{parentName:"p"},"all"),"\nedge cases, so for situations where the install params above are not sufficient, you may define an\n",(0,o.kt)("inlineCode",{parentName:"p"},"unpack_archive")," function."),(0,o.kt)("p",null,"This function receives an input with the following fields:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"input_file")," - Virtual path to the downloaded file. Maps to ",(0,o.kt)("inlineCode",{parentName:"li"},"~/.proto/temp/<id>/<file>"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"output_dir")," - Virtual directory to unpack the archive into, or copy the binary to. Maps to\n",(0,o.kt)("inlineCode",{parentName:"li"},"~/.proto/tools/<id>/<version>"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[plugin_fn]\npub fn unpack_archive(Json(input): Json<UnpackArchiveInput>) -> FnResult<()> {\n    untar(input.input_file, input.output_dir)?;\n    Ok(())\n}\n")),(0,o.kt)("h3",{id:"locating-binaries"},"Locating binaries"),(0,o.kt)("p",null,"Even though a tool has been installed, we must inform proto of where to find the binary to execute.\nThis can be achieved with the optional ",(0,o.kt)("inlineCode",{parentName:"p"},"locate_bins")," function. If this function is not defined,\nproto will assume the binary is named ",(0,o.kt)("inlineCode",{parentName:"p"},"<id>")," (",(0,o.kt)("inlineCode",{parentName:"p"},"<id>.exe")," on Windows), relative from the installation\ndirectory."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn locate_bins(Json(_): Json<LocateBinsInput>) -> FnResult<Json<LocateBinsOutput>> {\n    let env = get_proto_environment()?;\n\n    Ok(Json(LocateBinsOutput {\n        bin_path: Some(if env.os == HostOS::Windows {\n            "node.exe".into()\n        } else {\n            "bin/node".into()\n        }),\n        ..LocateBinsOutput::default()\n    }))\n}\n')),(0,o.kt)("p",null,"Furthermore, the ",(0,o.kt)("inlineCode",{parentName:"p"},"locate_bins")," function can define a list of lookups for the globals installation\ndirectory. proto will loop through each lookup, and return the first directory that exists on the\ncurrent file system. proto will also expand environment variables in the format of ",(0,o.kt)("inlineCode",{parentName:"p"},"$VAR_NAME"),". If a\nvariable is not defined, or has an empty value, the lookup will be skipped. To demonstrate this,\nwe'll use ",(0,o.kt)("a",{parentName:"p",href:"https://deno.land/manual@v1.35.0/tools/script_installer"},"Deno"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn locate_bins(Json(_): Json<LocateBinsInput>) -> FnResult<Json<LocateBinsOutput>> {\n    Ok(Json(LocateBinsOutput {\n        fallback_last_globals_dir: true,\n        globals_lookup_dirs: vec!["$DENO_INSTALL_ROOT/bin".into(), "$HOME/.deno/bin".into()],\n        ..LocateBinsOutput::default()\n    }))\n}\n')),(0,o.kt)("h3",{id:"loading-and-resolving-versions"},"Loading and resolving versions"),(0,o.kt)("p",null,"Now that the tool can be downloaded and installed, we must configure how to resolve available\nversions to actually be installed. To provide a list of versions and language specific aliases, the\n",(0,o.kt)("inlineCode",{parentName:"p"},"load_versions")," function must be defined."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn load_versions(Json(_): Json<LoadVersionsInput>) -> FnResult<Json<LoadVersionsOutput>> {\n    let mut output = LoadVersionsOutput::default();\n    let response: Vec<NodeDistVersion> = fetch_url("https://nodejs.org/dist/index.json")?;\n\n    for (index, item) in response.iter().enumerate() {\n        let version = Version::parse(&item.version[1..])?; // Starts with v\n\n        if index == 0 {\n            output.latest = Some(version.clone());\n        }\n\n        output.versions.push(version);\n    }\n\n    Ok(Json(output))\n}\n')),(0,o.kt)("p",null,"Furthermore, we support an optional function named ",(0,o.kt)("inlineCode",{parentName:"p"},"resolve_version"),", that can be defined to\nintercept the version resolution process. This function receives an input with an initial candidate,\neither an alias or version, and can replace it with a new candidate. The candidate must be a valid\nalias or version as defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"load_versions"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn resolve_version(\n    Json(input): Json<ResolveVersionInput>,\n) -> FnResult<Json<ResolveVersionOutput>> {\n    let mut output = ResolveVersionOutput::default();\n\n    if input.initial == "node" {\n        output.candidate = Some("latest".into());\n\n    } else if input.initial == "lts-*" || input.initial == "lts/*" {\n        output.candidate = Some("stable".into());\n\n    } else if input.initial.starts_with("lts-") || input.initial.starts_with("lts/") {\n        output.candidate = Some(input.initial[4..].to_owned());\n    }\n\n    Ok(Json(output))\n}\n')),(0,o.kt)("h3",{id:"detecting-versions"},"Detecting versions"),(0,o.kt)("p",null,"And lastly, we can configure how to ",(0,o.kt)("a",{parentName:"p",href:"./detection"},"detect a version")," contextually at runtime, using\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"detect_version_files")," function and optional ",(0,o.kt)("inlineCode",{parentName:"p"},"parse_version_file")," function. The\n",(0,o.kt)("inlineCode",{parentName:"p"},"detect_version_files")," function can return a list of files to locate within a directory."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn detect_version_files(_: ()) -> FnResult<Json<DetectVersionOutput>> {\n    Ok(Json(DetectVersionOutput {\n        files: vec![\n            ".nvmrc".into(),\n            ".node-version".into(),\n            "package.json".into(),\n        ],\n    }))\n}\n')),(0,o.kt)("p",null,'By default our plugin layer will assume the version file\'s contents contain the literal version, and\nnothing else, like "1.2.3". If any of the files in the ',(0,o.kt)("inlineCode",{parentName:"p"},"detect_version_files")," list require custom\nparsing (for example, ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," above), you can define the ",(0,o.kt)("inlineCode",{parentName:"p"},"parse_version_file")," function."),(0,o.kt)("p",null,"This function receives the file name and contents as input, and must return the parsed version (if\napplicable)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn parse_version_file(Json(input): Json<ParseVersionFileInput>) -> FnResult<Json<ParseVersionFileOutput>> {\n    let mut version = None;\n\n    if input.file == "package.json" {\n        let json: PackageJson = serde_json::from_str(&input.content)?;\n\n        if let Some(engines) = json.engines {\n            if let Some(constraint) = engines.get("node") {\n                version = Some(constraint.to_owned());\n            }\n        }\n    } else {\n        version = Some(input.content.trim().to_owned());\n    }\n\n    Ok(Json(ParseVersionFileOutput { version }))\n}\n')),(0,o.kt)("h3",{id:"creating-shims"},"Creating shims"),(0,o.kt)("p",null,"Tools within proto wouldn't function without shims, and as such, plugins can register their own\nshims to be created. By default, proto ",(0,o.kt)("em",{parentName:"p"},"will always")," create a global shim of the plugin at\n",(0,o.kt)("inlineCode",{parentName:"p"},"~/.proto/bin/<id>"),", but you can also register additional shims with the ",(0,o.kt)("inlineCode",{parentName:"p"},"create_shims")," function."),(0,o.kt)("h4",{id:"global-shims"},"Global shims"),(0,o.kt)("p",null,"Global shims are optional scripts that are available on ",(0,o.kt)("inlineCode",{parentName:"p"},"PATH")," as they are generated in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"~/.proto/bin")," directory, and can be defined with the ",(0,o.kt)("inlineCode",{parentName:"p"},"global_shims")," parameter. This param is a hash\nmap, where the key is the shim file name, and the value is a configuration object."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn create_shims(Json(_): Json<CreateShimsInput>) -> FnResult<Json<CreateShimsOutput>> {\n    let env = get_proto_environment()?;\n    let mut global_shims = HashMap::new();\n\n    global_shims.insert(\n        "npx".into(),\n        ShimConfig::global_with_alt_bin(if env.os == HostOS::Windows {\n            "npx.cmd".into()\n        } else {\n            "bin/npx".into()\n        }),\n    );\n\n    Ok(Json(CreateShimsOutput {\n        global_shims,\n        ..CreateShimsOutput::default()\n    }))\n}\n')),(0,o.kt)("p",null,"Furthermore, if you'd prefer to ",(0,o.kt)("em",{parentName:"p"},"not")," create a primary global shim at all, enable the\n",(0,o.kt)("inlineCode",{parentName:"p"},"no_primary_global")," field."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[plugin_fn]\npub fn create_shims(Json(_): Json<CreateShimsInput>) -> FnResult<Json<CreateShimsOutput>> {\n    Ok(Json(CreateShimsOutput {\n        no_primary_global: true,\n        ..CreateShimsOutput::default()\n    }))\n}\n")),(0,o.kt)("h3",{id:"installing-and-uninstalling-globals"},"Installing and uninstalling globals"),(0,o.kt)("p",null,"Most languages support the concept of installing packages/dependencies globally, and making them\navailable on ",(0,o.kt)("inlineCode",{parentName:"p"},"PATH"),". proto supports this with the\n",(0,o.kt)("a",{parentName:"p",href:"./commands/install-global"},(0,o.kt)("inlineCode",{parentName:"a"},"proto install-global"))," and\n",(0,o.kt)("a",{parentName:"p",href:"./commands/uninstall-global"},(0,o.kt)("inlineCode",{parentName:"a"},"proto uninstall-global"))," commands, which are simple convenience\nwrappers around the native binary."),(0,o.kt)("p",null,"From the context of the plugin, how globals are installed and uninstalled is implemented with the\n",(0,o.kt)("inlineCode",{parentName:"p"},"install_global")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"uninstall_global")," functions respectively. Both functions receive the\n",(0,o.kt)("inlineCode",{parentName:"p"},"dependency")," to install as input."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn install_global(\n    Json(input): Json<InstallGlobalInput>,\n) -> FnResult<Json<InstallGlobalOutput>> {\n    let result = exec_command!(inherit, "npm", ["install", "--global", &input.dependency]);\n\n    Ok(Json(InstallGlobalOutput::from_exec_command(result)))\n}\n\n#[plugin_fn]\npub fn uninstall_global(\n    Json(input): Json<UninstallGlobalInput>,\n) -> FnResult<Json<UninstallGlobalOutput>> {\n    let result = exec_command!(inherit, "npm", ["uninstall", "--global", &input.dependency]);\n\n    Ok(Json(UninstallGlobalOutput::from_exec_command(result)))\n}\n')),(0,o.kt)("h2",{id:"testing"},"Testing"),(0,o.kt)("p",null,"The best way to test the plugin is to execute it through ",(0,o.kt)("inlineCode",{parentName:"p"},"proto")," directly. To do this, you'll need\nto configure a ",(0,o.kt)("inlineCode",{parentName:"p"},".prototools")," file at the root of your plugin's repository that maps the plugin to a\ndebug build:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-toml"},'[plugins]\n<id> = "source:target/wasm32-wasi/debug/<name>.wasm"\n')),(0,o.kt)("p",null,"And everytime you make a change to the plugin, you'll need to rebuild it with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"cargo wasi build\n")),(0,o.kt)("p",null,"With these 2 pieces in place, you can now execute ",(0,o.kt)("inlineCode",{parentName:"p"},"proto")," commands. Be sure you're running them from\nthe directory with the ",(0,o.kt)("inlineCode",{parentName:"p"},".prototools")," file, and that you're passing ",(0,o.kt)("inlineCode",{parentName:"p"},"--log trace"),". Logs are extremely\nhelpful for figuring out what's going on."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"proto --log trace install <id>\nproto --log trace list-remote <id>\n...\n")),(0,o.kt)("h3",{id:"unit-tests"},"Unit tests"),(0,o.kt)("p",null,"Testing WASM plugins is a bit tricky, but we've taken it upon ourselves to streamline this process\nas much as possible with built-in test utilities, and Rust macros for generating common test cases.\nTo begin, install all necessary development dependencies:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"cargo add --dev proto_core proto_pdk_test_utils starbase_sandbox tokio\n")),(0,o.kt)("p",null,"And as mentioned above, everytime you make a change to the plugin, you'll need to rebuild it with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"cargo wasi build\n")),(0,o.kt)("h4",{id:"testing-plugin-functions"},"Testing plugin functions"),(0,o.kt)("p",null,"The common test case is simply calling plugin functions with a provided input and asserting the\noutput is correct. This can be achieved by creating a plugin instance with ",(0,o.kt)("inlineCode",{parentName:"p"},"create_plugin")," and\ncalling the appropriate method."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use proto_pdk_test_utils::*;\nuse starbase_sandbox::create_empty_sandbox;\n\n#[test]\nfn registers_metadata() {\n    let sandbox = create_empty_sandbox();\n    let plugin = create_plugin("id", sandbox.path());\n\n    assert_eq!(\n        plugin.register_tool(ToolMetadataInput::default()),\n        ToolMetadataOutput {\n            name: "Name".into(),\n            ..ToolMetadataOutput::default()\n        }\n    );\n}\n')),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"We suggest using this pattern for static functions that return a deterministic output from a\nprovided input, and not for dynamic functions that make HTTP requests or execute host commands.")),(0,o.kt)("h4",{id:"generating-cases-from-macros"},"Generating cases from macros"),(0,o.kt)("p",null,"To reduce the burden of writing custom tests for common flows, like downloading a pre-built,\nresolving versions, and generating shims, we provide a set of Rust decl macros that will generate\nthe tests for you."),(0,o.kt)("p",null,"To test downloading and installing, use ",(0,o.kt)("inlineCode",{parentName:"p"},"generate_download_install_tests!"),". This macro requires a\nplugin ID and a real version to test with."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use proto_pdk_test_utils::*;\nuse starbase_sandbox::create_empty_sandbox;\n\ngenerate_download_install_tests!("id", "1.2.3");\n')),(0,o.kt)("p",null,"To test version resolving, use ",(0,o.kt)("inlineCode",{parentName:"p"},"generate_resolve_versions_tests!"),". This macro requires a plugin ID,\nand a mapping of version/aliases assertions to expectations."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'generate_resolve_versions_tests!("id", {\n    "0.4" => "0.4.12",\n    "0.5.1" => "0.5.1",\n    "stable" => "1.0.0",\n});\n')),(0,o.kt)("p",null,"To test installing and uninstalling globals, use ",(0,o.kt)("inlineCode",{parentName:"p"},"generate_globals_test!"),". This macro requires a\nplugin ID, the dependency to install, and an optional environment variable to the globals directory."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Doesn\'t support all use cases! If this doesn\'t work, implement a test case manually.\ngenerate_globals_test!("id", "dependency", "GLOBAL_INSTALL_ROOT");\n')),(0,o.kt)("p",null,"And lastly, to test shims, use ",(0,o.kt)("inlineCode",{parentName:"p"},"generate_global_shims_test!")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"generate_local_shims_test!"),". Both\nmacros require a plugin ID, but also support additional arguments when creating more than 1 shim.\nThese macros generate snapshots using ",(0,o.kt)("a",{parentName:"p",href:"https://insta.rs/"},"Insta"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// Only the single binary\ngenerate_global_shims_test!("id");\n\n// When creating alternate/additional globals\ngenerate_global_shims_test!("id", ["other", "another"]);\n\n// When creating local shims, each file required in the list\ngenerate_local_shims_test!("id", ["a", "b", "c"]);\n')),(0,o.kt)("h2",{id:"building-and-publishing"},"Building and publishing"),(0,o.kt)("p",null,"At this point, you should have a fully working WASM plugin, but to make it available to downstream\nproto users, you'll still need to build and make the ",(0,o.kt)("inlineCode",{parentName:"p"},".wasm")," file available. The easiest solution is\nto publish a GitHub release and include the ",(0,o.kt)("inlineCode",{parentName:"p"},".wasm")," file as an asset."),(0,o.kt)("h3",{id:"manually-create-releases"},"Manually create releases"),(0,o.kt)("p",null,"When your plugin is ready to be published, you can create a release on GitHub using the following\nsteps."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Tag the release and push to GitHub.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"git tag v0.0.1\ngit push --tags\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Build a release version of the plugin. The file will be available at\n",(0,o.kt)("inlineCode",{parentName:"li"},"target/wasm32-wasi/release/<name>.wasm"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"cargo wasi build --release\n")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"In GitHub, navigate to the tags page, find the new tag, create a new release, and attach the\nbuilt file as an asset.")),(0,o.kt)("h3",{id:"automate-releases"},"Automate releases"),(0,o.kt)("p",null,"Coming soon!"),(0,o.kt)("h2",{id:"resources"},"Resources"),(0,o.kt)("p",null,"Some helpful resources for learning about and building plugins."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Official proto WASM plugins",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/moonrepo/bun-plugin"},"Bun")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/moonrepo/deno-plugin"},"Deno")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/moonrepo/go-plugin"},"Go")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/moonrepo/node-plugin"},"Node")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/moonrepo/node-plugin"},"npm, pnpm, yarn")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/moonrepo/rust-plugin"},"Rust")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/moonrepo/schema-plugin"},"Schema")))),(0,o.kt)("li",{parentName:"ul"},"Plugin development kit",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/proto_pdk/"},(0,o.kt)("inlineCode",{parentName:"a"},"proto_pdk")," docs")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.rs/proto_pdk_test_utils/"},(0,o.kt)("inlineCode",{parentName:"a"},"proto_pdk_test_utils")," docs"))))))}d.isMDXComponent=!0}}]);