"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[68026],{35318:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(27378);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},39798:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(27378),o=n(37140);const i="tabItem_wHwb";function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(i,r),hidden:n},t)}},33337:(e,t,n)=>{n.d(t,{Z:()=>h});var a=n(25773),o=n(27378),i=n(37140),r=n(83457),s=n(35595),l=n(76457);const p="tabList_J5MA",c="tabItem_l0OV";function d(e){let{className:t,block:n,selectedValue:s,selectValue:l,tabValues:p}=e;const d=[],{blockElementScrollPositionUntilNextRender:u}=(0,r.o5)(),m=e=>{const t=e.currentTarget,n=d.indexOf(t),a=p[n].value;a!==s&&(u(t),l(a))},h=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const n=d.indexOf(e.currentTarget)+1;t=d[n]??d[0];break}case"ArrowLeft":{const n=d.indexOf(e.currentTarget)-1;t=d[n]??d[d.length-1];break}}t?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},p.map((e=>{let{value:t,label:n,attributes:r}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>d.push(e),onKeyDown:h,onClick:m},r,{className:(0,i.Z)("tabs__item",c,r?.className,{"tabs__item--active":s===t})}),n??t)})))}function u(e){let{lazy:t,children:n,selectedValue:a}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===a));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},i.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function m(e){const t=(0,s.Y)(e);return o.createElement("div",{className:(0,i.Z)("tabs-container",p)},o.createElement(d,(0,a.Z)({},e,t)),o.createElement(u,(0,a.Z)({},e,t)))}function h(e){const t=(0,l.Z)();return o.createElement(m,(0,a.Z)({key:String(t)},e))}},35595:(e,t,n)=>{n.d(t,{Y:()=>u});var a=n(27378),o=n(35331),i=n(30654),r=n(70784),s=n(71819);function l(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:o}}=e;return{value:t,label:n,attributes:a,default:o}}))}function p(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??l(n);return function(e){const t=(0,r.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function c(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function d(e){let{queryString:t=!1,groupId:n}=e;const r=(0,o.k6)(),s=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,i._X)(s),(0,a.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(r.location.search);t.set(s,e),r.replace({...r.location,search:t.toString()})}),[s,r])]}function u(e){const{defaultValue:t,queryString:n=!1,groupId:o}=e,i=p(e),[r,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!c({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[u,m]=d({queryString:n,groupId:o}),[h,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[o,i]=(0,s.Nk)(n);return[o,(0,a.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:o}),g=(()=>{const e=u??h;return c({value:e,tabValues:i})?e:null})();(0,a.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:r,selectValue:(0,a.useCallback)((e=>{if(!c({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),m(e),f(e)}),[m,f,i]),tabValues:i}}},88109:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(27378);function o(e){let{src:t,width:n="90%",alt:o="",title:i,align:r="center",padding:s="1rem"}=e;return a.createElement("div",{style:{marginBottom:s,marginTop:s,textAlign:r}},a.createElement("img",{src:t.default,width:n,alt:o,title:i,className:"inline-block"}))}},8e3:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>h,frontMatter:()=>l,metadata:()=>c,toc:()=>u});var a=n(25773),o=(n(27378),n(35318)),i=n(33337),r=n(39798),s=n(88109);const l={title:"TypeScript project references",toc_max_heading_level:6},p=void 0,c={unversionedId:"guides/javascript/typescript-project-refs",id:"guides/javascript/typescript-project-refs",title:"TypeScript project references",description:"The ultimate in-depth guide for using TypeScript in a monorepo effectively!",source:"@site/docs/guides/javascript/typescript-project-refs.mdx",sourceDirName:"guides/javascript",slug:"/guides/javascript/typescript-project-refs",permalink:"/docs/guides/javascript/typescript-project-refs",draft:!1,editUrl:"https://github.com/moonrepo/moon/tree/master/website/docs/guides/javascript/typescript-project-refs.mdx",tags:[],version:"current",frontMatter:{title:"TypeScript project references",toc_max_heading_level:6},sidebar:"guides",previous:{title:"Task profiling",permalink:"/docs/guides/profile"},next:{title:"Examples",permalink:"/docs/guides/node/examples"}},d={},u=[{value:"Preface",id:"preface",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Root-level",id:"root-level",level:3},{value:"<code>tsconfig.json</code>",id:"tsconfigjson",level:4},{value:"<code>tsconfig.options.json</code>",id:"tsconfigoptionsjson",level:4},{value:"ECMAScript interoperability",id:"ecmascript-interoperability",level:5},{value:"<code>.gitignore</code>",id:"gitignore",level:4},{value:"Project-level",id:"project-level",level:3},{value:"<code>tsconfig.json</code>",id:"tsconfigjson-1",level:4},{value:"Includes and excludes",id:"includes-and-excludes",level:5},{value:"Depending on other projects",id:"depending-on-other-projects",level:5},{value:"<code>tsconfig.*.json</code>",id:"tsconfigjson-2",level:4},{value:"Package publishing",id:"package-publishing",level:5},{value:"Vendor specific",id:"vendor-specific",level:5},{value:"Running the typechecker",id:"running-the-typechecker",level:2},{value:"On all projects",id:"on-all-projects",level:3},{value:"On an individual project",id:"on-an-individual-project",level:3},{value:"On affected projects",id:"on-affected-projects",level:3},{value:"Using <code>paths</code> aliases",id:"using-paths-aliases",level:2},{value:"Importing source files from local packages",id:"importing-source-files-from-local-packages",level:3},{value:"Sharing and augmenting types",id:"sharing-and-augmenting-types",level:2},{value:"Supporting <code>package.json</code> exports",id:"supporting-packagejson-exports",level:2},{value:"State of the npm ecosystem",id:"state-of-the-npm-ecosystem",level:3},{value:"Enabling imports/exports resolution",id:"enabling-importsexports-resolution",level:3},{value:"Resolving issues",id:"resolving-issues",level:3},{value:"Editor integration",id:"editor-integration",level:2},{value:"VS Code",id:"vs-code",level:3},{value:"FAQ",id:"faq",level:2},{value:"I still have questions, where can I ask them?",id:"i-still-have-questions-where-can-i-ask-them",level:3},{value:"Do I have to use project references?",id:"do-i-have-to-use-project-references",level:3},{value:"What about not using project references and only using source files?",id:"what-about-not-using-project-references-and-only-using-source-files",level:3},{value:"How to integrate with ESLint?",id:"how-to-integrate-with-eslint",level:3},{value:"How to handle circular references?",id:"how-to-handle-circular-references",level:3}],m={toc:u};function h(e){let{components:t,...l}=e;return(0,o.kt)("wrapper",(0,a.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The ultimate in-depth guide for using TypeScript in a monorepo effectively!")),(0,o.kt)("p",null,"How to use TypeScript in a monorepo? What are project references? Why use project references? What\nis the best way to use project references? These are just a handful of questions that are\n",(0,o.kt)("em",{parentName:"p"},"constantly")," asked on Twitter, forums, Stack Overflow, and even your workplace."),(0,o.kt)("p",null,"Based on years of experience managing large-scale frontend repositories, we firmly believe that\nTypeScript project references are the proper solution for effectively scaling TypeScript in a\nmonorepo. The official\n",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/project-references.html"},"TypeScript documentation on project references"),"\nanswers many of these questions, but it basically boils down to the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Project references ",(0,o.kt)("em",{parentName:"li"},"enforce project boundaries, disallowing imports")," to arbitrary projects unless\nthey have been referenced explicitly in configuration. This avoids circular references / cycles."),(0,o.kt)("li",{parentName:"ul"},"It enables TypeScript to ",(0,o.kt)("em",{parentName:"li"},"process individual units"),", instead of the entire repository as a whole.\nPerfect for reducing CI and local development times."),(0,o.kt)("li",{parentName:"ul"},"It supports ",(0,o.kt)("em",{parentName:"li"},"incremental compilation"),", so only out-of-date or affected projects are processed. The\nmore TypeScript's cache is warmed, the faster it will be."),(0,o.kt)("li",{parentName:"ul"},"It simulates how types work in the Node.js package ecosystem.")),(0,o.kt)("p",null,"This all sounds amazing but there's got to be some downsides right? Unfortunately, there is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Project references require generating declarations to resolve type information correctly. This\nresults in a lot of compilation artifacts littered throughout the repository. There\n",(0,o.kt)("a",{parentName:"li",href:"#gitignore"},"are ways")," ",(0,o.kt)("a",{parentName:"li",href:"../../config/toolchain#routeoutdirtocache"},"around this"),"."),(0,o.kt)("li",{parentName:"ul"},"This approach is a bit involved and may require some cognitive overhead based on your current\nlevel of TypeScript tooling knowledge.")),(0,o.kt)("admonition",{type:"success"},(0,o.kt)("p",{parentName:"admonition"},"If you'd like a real-world repository to reference, our\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/moonrepo/moon"},"moonrepo/moon"),", ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/moonrepo/dev"},"moonrepo/dev"),",\nand ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/moonrepo/examples"},"moonrepo/examples")," repositories utilizes this\narchitecture!")),(0,o.kt)("h2",{id:"preface"},"Preface"),(0,o.kt)("p",null,"Before you dive into this questionably long guide, we'd like to preface with:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"This guide is a living document and will continually be updated with best practices and frequently\nasked questions. Keep returning to learn more!"),(0,o.kt)("li",{parentName:"ul"},"This guide assumes a basic level knowledge of TypeScript and how it works."),(0,o.kt)("li",{parentName:"ul"},"The architecture outlined in this guide assumes that TypeScript is ",(0,o.kt)("em",{parentName:"li"},"only")," used for typechecking\nand ",(0,o.kt)("em",{parentName:"li"},"not")," compiling. However, supporting compilation should be as easy as modifying a handful of\ncompiler options."),(0,o.kt)("li",{parentName:"ul"},"Although this guide exists within moon's documentation, it ",(0,o.kt)("em",{parentName:"li"},"does not")," require moon. We've kept all\nimplementation details generic enough for it be used in any repository, but have also included\nmany notes on how moon would improve this experience.")),(0,o.kt)("h2",{id:"configuration"},"Configuration"),(0,o.kt)("p",null,"The most complicated part of integrating TypeScript in a monorepo is a proper configuration setup.\nBased on our extensive experience, we suggest the following architecture as a base! This ",(0,o.kt)("em",{parentName:"p"},"is not"),"\nperfect and can most definitely be expanded upon or modified to fit your needs."),(0,o.kt)("h3",{id:"root-level"},"Root-level"),(0,o.kt)("p",null,"In a polyrepo, the root ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," is typically the only configuration file, as it defines\ncommon compiler options, and includes files to typecheck. In a monorepo, these responsibilites are\nnow split across multiple configuration files."),(0,o.kt)("h4",{id:"tsconfigjson"},(0,o.kt)("inlineCode",{parentName:"h4"},"tsconfig.json")),(0,o.kt)("p",null,"To start, the root ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," file is nothing more than a list of ",(0,o.kt)("em",{parentName:"p"},"all")," projects in the\nmonorepo, with each project being an individual entry in the ",(0,o.kt)("inlineCode",{parentName:"p"},"references")," field. Each entry must\ncontain a ",(0,o.kt)("inlineCode",{parentName:"p"},"path")," field with a relative file system path to the project root (that contains their\nconfig)."),(0,o.kt)("p",null,"We also ",(0,o.kt)("em",{parentName:"p"},"do not")," define compiler options in this file, as project-level configuration files would\n",(0,o.kt)("em",{parentName:"p"},"not")," be able to extend this file, as it would trigger a circular reference. Instead, we define\ncommon compiler options in a root ",(0,o.kt)("a",{parentName:"p",href:"#tsconfigoptionsjson"},(0,o.kt)("inlineCode",{parentName:"a"},"tsconfig.options.json"))," file, that this\nfile also ",(0,o.kt)("inlineCode",{parentName:"p"},"extends")," from."),(0,o.kt)("p",null,"In the end, this file should only contain 3 fields: ",(0,o.kt)("inlineCode",{parentName:"p"},"extends"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"files")," (an empty list), and\n",(0,o.kt)("inlineCode",{parentName:"p"},"references"),". This abides the\n",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/project-references.html#overall-structure"},"official guidance around structure"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'file="tsconfig.json"',file:'"tsconfig.json"'},'{\n  "extends": "./tsconfig.options.json",\n  "files": [],\n  "references": [\n    {\n      "path": "apps/foo"\n    },\n    {\n      "path": "packages/bar"\n    }\n    // ... more\n  ]\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"When using moon, the\n",(0,o.kt)("a",{parentName:"p",href:"../../config/toolchain#syncprojectreferences"},(0,o.kt)("inlineCode",{parentName:"a"},"typescript.syncProjectReferences"))," setting will\nkeep this ",(0,o.kt)("inlineCode",{parentName:"p"},"references")," list automatically in sync, and the name of the file can be customized with\n",(0,o.kt)("a",{parentName:"p",href:"../../config/toolchain#rootconfigfilename"},(0,o.kt)("inlineCode",{parentName:"a"},"typescript.rootConfigFileName")),".")),(0,o.kt)("h4",{id:"tsconfigoptionsjson"},(0,o.kt)("inlineCode",{parentName:"h4"},"tsconfig.options.json")),(0,o.kt)("p",null,"This file will contain common compiler options that will be inherited by ",(0,o.kt)("em",{parentName:"p"},"all")," projects in the\nmonorepo. For project references to work correctly, the following settings ",(0,o.kt)("em",{parentName:"p"},"must")," be enabled at the\nroot, and typically should not be disabled in each project."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"composite")," - Enables project references and informs the TypeScript program where to find\nreferenced outputs."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"declaration")," - Project references rely on the compiled declarations (",(0,o.kt)("inlineCode",{parentName:"li"},".d.ts"),") of external\nprojects. If declarations do not exist, TypeScript will generate them on demand."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"declarationMap"),' - Generate sourcemaps for declarations, so that language server integrations in\neditors like "Go to" resolve correctly.'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"emitDeclarationOnly")," - Project references only require declarations, so avoid compiling to\nJavaScript."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"incremental")," - Enables incremental compilation, greatly improving performance."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"noEmitOnError")," - If the typechecker fails, avoid generating invalid or partial declarations."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"skipLibCheck")," - Avoids eager loading and analyzing all declarations, greatly improving\nperformance.")),(0,o.kt)("p",null,"For convenience, we provide the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/moonrepo/dev/tree/master/packages/tsconfig"},(0,o.kt)("inlineCode",{parentName:"a"},"tsconfig-moon"))," package, which\ndefines common compiler options and may be used here."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'file="tsconfig.options.json"',file:'"tsconfig.options.json"'},'{\n  "compilerOptions": {\n    "composite": true,\n    "declaration": true,\n    "declarationMap": true,\n    "emitDeclarationOnly": true,\n    "incremental": true,\n    "noEmitOnError": true,\n    "skipLibCheck": true\n    // ... others\n  }\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"When using moon, the name of the file can be customized with\n",(0,o.kt)("a",{parentName:"p",href:"../../config/toolchain#rootoptionsconfigfilename"},(0,o.kt)("inlineCode",{parentName:"a"},"typescript.rootOptionsConfigFileName")),".")),(0,o.kt)("h5",{id:"ecmascript-interoperability"},"ECMAScript interoperability"),(0,o.kt)("p",null,"ECMAScript modules (ESM) have been around for quite a while now, but the default TypeScript settings\nare not configured for them. We suggest the following compiler options if you want proper ESM\nsupport with interoperability with the ecosystem."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'file="tsconfig.options.json"',file:'"tsconfig.options.json"'},'{\n  "compilerOptions": {\n    "allowSyntheticDefaultImports": true,\n    "esModuleInterop": true,\n    "isolatedModules": true,\n    "module": "esnext",\n    "moduleResolution": "node",\n    "strict": true,\n    "target": "esnext"\n    // ... others\n  }\n}\n')),(0,o.kt)("h4",{id:"gitignore"},(0,o.kt)("inlineCode",{parentName:"h4"},".gitignore")),(0,o.kt)("p",null,"Project references unfortunately generate ",(0,o.kt)("em",{parentName:"p"},"a ton")," of artifacts that typically shouldn't be committed\nto the repository (but could be if you so choose). We suggest ignoring the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell",metastring:'title=".gitignore"',title:'".gitignore"'},"# The `outDir` for declarations\nlib/\n# Build cache manifests\n*.tsbuildinfo\n")),(0,o.kt)("h3",{id:"project-level"},"Project-level"),(0,o.kt)("p",null,"Each project that contains TypeScript files and will utilize the typechecker ",(0,o.kt)("em",{parentName:"p"},"must")," contain a\n",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," in the project root, typically as a sibling to ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json"),"."),(0,o.kt)("h4",{id:"tsconfigjson-1"},(0,o.kt)("inlineCode",{parentName:"h4"},"tsconfig.json")),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," in the root of a project (application or package) is required, as it informs\nTypeScript that this is a project, and that it can be referenced by other projects. In its simplest\nform, this file should extend the root ",(0,o.kt)("a",{parentName:"p",href:"#tsconfigoptionsjson"},(0,o.kt)("inlineCode",{parentName:"a"},"tsconfig.options.json"))," to inherit\ncommon compiler options, define its own compiler options (below), define includes/excludes, and any\nnecessary references."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"When using moon, the name of the file can be customized with\n",(0,o.kt)("a",{parentName:"p",href:"../../config/toolchain#projectconfigfilename"},(0,o.kt)("inlineCode",{parentName:"a"},"typescript.projectConfigFileName")),".")),(0,o.kt)(i.Z,{groupId:"project-type",defaultValue:"app",values:[{label:"Applications",value:"app"},{label:"Packages",value:"package"}],mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"app",mdxType:"TabItem"},(0,o.kt)("p",null,"For applications, declaration emitting can be disabled, since external projects ",(0,o.kt)("em",{parentName:"p"},"should not")," be\nimporting files from an application. If this use case ever arises, move those files into a package."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="apps/foo/tsconfig.json"',title:'"apps/foo/tsconfig.json"'},'{\n  "extends": "../../../../tsconfig.options.json",\n  "compilerOptions": {\n    "emitDeclarationOnly": false,\n    "noEmit": true\n  },\n  "include": [],\n  "references": []\n}\n'))),(0,o.kt)(r.Z,{value:"package",mdxType:"TabItem"},(0,o.kt)("p",null,"For packages, we must define the location in which to generate declarations. These are the\ndeclarations that external projects would reference. This location is typically\n",(0,o.kt)("a",{parentName:"p",href:"#gitignore"},"gitignored"),"!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="packages/bar/tsconfig.json"',title:'"packages/bar/tsconfig.json"'},'{\n  "extends": "../../../../tsconfig.options.json",\n  "compilerOptions": {\n    "outDir": "./lib"\n  },\n  "include": [],\n  "references": []\n}\n')))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"When using moon, the ",(0,o.kt)("inlineCode",{parentName:"p"},"outDir")," can automatically be re-routed to a shared cache using\n",(0,o.kt)("a",{parentName:"p",href:"../../config/toolchain#routeoutdirtocache"},(0,o.kt)("inlineCode",{parentName:"a"},"typescript.routeOutDirToCache")),", to avoid littering\nthe repository with compilation artifacts.")),(0,o.kt)("h5",{id:"includes-and-excludes"},"Includes and excludes"),(0,o.kt)("p",null,"Based on experience, we suggest defining ",(0,o.kt)("inlineCode",{parentName:"p"},"include")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"exclude"),", as managing a whitelist of\ntypecheckable files is much easier. When dealing with excludes, there are far too many\npossibilities. To start, you have ",(0,o.kt)("inlineCode",{parentName:"p"},"node_modules"),", and for applications maybe ",(0,o.kt)("inlineCode",{parentName:"p"},"dist"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"build"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},".next"),", or another application specific folder, and then for packages you may have ",(0,o.kt)("inlineCode",{parentName:"p"},"lib"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"cjs"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"esm"),", etc. It becomes very... tedious."),(0,o.kt)("p",null,"The other benefit of using ",(0,o.kt)("inlineCode",{parentName:"p"},"include")," is that it forces TypeScript to only load ",(0,o.kt)("em",{parentName:"p"},"what's necessary"),",\ninstead of eager loading everything into memory, and for typechecking files that aren't part of\nsource, like configuration."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="<project>/tsconfig.json"',title:'"<project>/tsconfig.json"'},'{\n  // ...\n  "include": ["src/**/*", "tests/**/*", "*.js", "*.ts"]\n}\n')),(0,o.kt)("h5",{id:"depending-on-other-projects"},"Depending on other projects"),(0,o.kt)("p",null,"When a project depends on another project (by importing code from it), either using relative paths,\n",(0,o.kt)("a",{parentName:"p",href:"#using-paths-aliases"},"path aliases"),", or its ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," name, it must be declared as a\nreference. If not declared, TypeScript will error with a message about importing outside the project\nboundary."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="<project>/tsconfig.json"',title:'"<project>/tsconfig.json"'},'{\n  // ...\n  "references": [\n    {\n      "path": "../../foo"\n    },\n    {\n      "path": "../../bar"\n    },\n    {\n      "path": "../../../../baz"\n    }\n  ]\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"When using moon, the\n",(0,o.kt)("a",{parentName:"p",href:"../../config/toolchain#syncprojectreferences"},(0,o.kt)("inlineCode",{parentName:"a"},"typescript.syncProjectReferences"))," setting will\nkeep this ",(0,o.kt)("inlineCode",{parentName:"p"},"references")," list automatically in sync.")),(0,o.kt)("h4",{id:"tsconfigjson-2"},(0,o.kt)("inlineCode",{parentName:"h4"},"tsconfig.*.json")),(0,o.kt)("p",null,"Additional configurations may exist in a project that serve a role outside of typechecking, with one\nsuch role being ",(0,o.kt)("em",{parentName:"p"},"npm package publishing"),". These configs are sometimes named ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.build.json"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.types.json"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.lib.json"),". Regardless of what they're called, these configs are\n",(0,o.kt)("em",{parentName:"p"},"optional"),", so unless you have a business need for them, you may skip this section."),(0,o.kt)("h5",{id:"package-publishing"},"Package publishing"),(0,o.kt)("p",null,"As mentioned previously, these configs may be used for npm packages, primarily for generating\nTypeScript declarations that are mapped through the ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json"),"\n",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html"},(0,o.kt)("inlineCode",{parentName:"a"},"types")," (or ",(0,o.kt)("inlineCode",{parentName:"a"},"typings"),") field"),"."),(0,o.kt)("p",null,"Given this ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json"),"..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="<project>/package.json"',title:'"<project>/package.json"'},'{\n  // ...\n  "types": "./lib/index.d.ts"\n}\n')),(0,o.kt)("p",null,"Our ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.build.json")," may look like..."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="<project>/tsconfig.build.json"',title:'"<project>/tsconfig.build.json"'},'{\n  "extends": "../../../../tsconfig.options.json",\n  "compilerOptions": {\n    "outDir": "lib",\n    "rootDir": "src"\n  },\n  "include": ["src/**/*"]\n}\n')),(0,o.kt)("p",null,"Simple right? But why do we need an additional configuration? Why not use the other ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json"),"?\nGreat questions! The major reason is that we ",(0,o.kt)("em",{parentName:"p"},"only want to publish declarations for source files"),",\nand the declarations file structure should match 1:1 with the sources structure. The ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json"),"\n",(0,o.kt)("em",{parentName:"p"},"does not")," guarantee this, as it may include test, config, or arbitrary files, all of which may not\nexist in the sources directory (",(0,o.kt)("inlineCode",{parentName:"p"},"src"),"), and will alter the output to an incorrect directory\nstructure. Our ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.build.json")," solves this problem by only including source files, and by\nforcing the source root to ",(0,o.kt)("inlineCode",{parentName:"p"},"src")," using the ",(0,o.kt)("inlineCode",{parentName:"p"},"rootDir")," compiler option."),(0,o.kt)("p",null,"However, there is a giant caveat with this approach! Because TypeScript utilizes Node.js's module\nresolution, it will reference the declarations defined by the ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," ",(0,o.kt)("inlineCode",{parentName:"p"},"types")," or\n",(0,o.kt)("a",{parentName:"p",href:"#supporting-packagejson-exports"},(0,o.kt)("inlineCode",{parentName:"a"},"exports"))," fields, instead of the ",(0,o.kt)("inlineCode",{parentName:"p"},"outDir")," compiler option, and\nthe other ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," ",(0,o.kt)("em",{parentName:"p"},"does not guarantee")," these files will exist. This results in TypeScript\nfailing to find the appropriate types! To solve this, add the ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.build.json")," as a project\nreference to ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="<project>/tsconfig.json"',title:'"<project>/tsconfig.json"'},'{\n  // ...\n  "references": [\n    {\n      "path": "./tsconfig.build.json"\n    }\n    // ... others\n  ]\n}\n')),(0,o.kt)("h5",{id:"vendor-specific"},"Vendor specific"),(0,o.kt)("p",null,"Some vendors, like ",(0,o.kt)("a",{parentName:"p",href:"../examples/vite"},"Vite"),", ",(0,o.kt)("a",{parentName:"p",href:"../examples/vite"},"Vitest"),", and\n",(0,o.kt)("a",{parentName:"p",href:"../examples/astro"},"Astro")," may include additional ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.*.json")," files unique to their ecosystem.\nWe suggest following their guidelines and implementation when applicable."),(0,o.kt)("h2",{id:"running-the-typechecker"},"Running the typechecker"),(0,o.kt)("p",null,"Now that our configuration is place, we can run the typechecker, or attempt to at least! This can be\ndone with the ",(0,o.kt)("inlineCode",{parentName:"p"},"tsc --build")," command, which acts as a\n",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/project-references.html#build-mode-for-typescript"},"build orchestrator"),".\nWe also suggest passing ",(0,o.kt)("inlineCode",{parentName:"p"},"--verbose")," for insights into what projects are compiling, and which are\nout-of-date."),(0,o.kt)("h3",{id:"on-all-projects"},"On all projects"),(0,o.kt)("p",null,"From the root of the repository, run ",(0,o.kt)("inlineCode",{parentName:"p"},"tsc --build --verbose")," to typecheck ",(0,o.kt)("em",{parentName:"p"},"all")," projects, as defined\nin ",(0,o.kt)("a",{parentName:"p",href:"#tsconfigjson"},"tsconfig.json"),". TypeScript will generate a directed acyclic graph (DAG) and\ncompile projects ",(0,o.kt)("em",{parentName:"p"},"in order")," so that dependencies and references are resolved correctly."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Why run TypeScript in the root? Typically you would only want to run against projects, but for\nsituations where you need to verify that all projects still work, running in the root is the best\napproach. Some such situations are upgrading TypeScript itself, upgrading global ",(0,o.kt)("inlineCode",{parentName:"p"},"@types")," packages,\nupdating shared types, reworking build processes, and more.")),(0,o.kt)("h3",{id:"on-an-individual-project"},"On an individual project"),(0,o.kt)("p",null,"To only typecheck a single project (and its dependencies), there are 2 approaches. The first is to\nrun from the root, and pass a relative path to the project, such as\n",(0,o.kt)("inlineCode",{parentName:"p"},"tsc --build --verbose packages/foo"),". The second is to change the working directory to the project,\nand run from there, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"cd packages/foo && tsc --build --verbose"),"."),(0,o.kt)("p",null,"Both approaches are viable, and either may be used based on your tooling, build system, task runner,\nso on and so forth. This is the approach moon suggests with its\n",(0,o.kt)("a",{parentName:"p",href:"../examples/typescript"},(0,o.kt)("inlineCode",{parentName:"a"},"typecheck")," task"),"."),(0,o.kt)("h3",{id:"on-affected-projects"},"On affected projects"),(0,o.kt)("p",null,"In CI environments, it's nice to ",(0,o.kt)("em",{parentName:"p"},"only run")," the typechecker on affected projects \u2014 projects that\nhave changed files. While this isn't entirely possible with ",(0,o.kt)("inlineCode",{parentName:"p"},"tsc"),", it is possible with moon! Head\nover to the\n",(0,o.kt)("a",{parentName:"p",href:"../../run-task#running-based-on-affected-files-only"},"official docs for more information"),"."),(0,o.kt)("h2",{id:"using-paths-aliases"},"Using ",(0,o.kt)("inlineCode",{parentName:"h2"},"paths")," aliases"),(0,o.kt)("p",null,"Path aliases, also known as path mapping or magic imports, is the concept of defining an import\nalias that re-maps its underlying location on the file system. In TypeScript, this is achieved with\nthe\n",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping"},(0,o.kt)("inlineCode",{parentName:"a"},"paths")," compiler option"),"."),(0,o.kt)("p",null,'In a monorepo world, we suggest using path aliases on a per-project basis, instead of defining them\n"globally" in the root. This gives projects full control of what\'s available and what they want to\nimport, and also plays nice with the mandatory ',(0,o.kt)("inlineCode",{parentName:"p"},"baseUrl")," compiler option."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="<project>/tsconfig.json"',title:'"<project>/tsconfig.json"'},'{\n  // ...\n  "compilerOptions": {\n    // ...\n    "baseUrl": ".",\n    "paths": {\n      // Within the project\n      ":components/*": ["./src/components/*"],\n      // To a referenced project\n      ":shared/*": ["../../shared/code/*"]\n    }\n  },\n  "references": [\n    {\n      "path": "../../shared/code"\n    }\n  ]\n}\n')),(0,o.kt)("p",null,"The above aliases would be imported like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// Before\nimport { Button } from '../../../../components/Button';\nimport utils from '../../shared/code/utils';\n\n// After\nimport { Button } from ':components/Button';\nimport utils from ':shared/utils';\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"When using path aliases, we suggest prefixing or suffixing the alias with ",(0,o.kt)("inlineCode",{parentName:"p"},":")," so that it's apparent\nthat it's an alias (this also matches the new ",(0,o.kt)("inlineCode",{parentName:"p"},"node:")," import syntax). Using no special character or\n",(0,o.kt)("inlineCode",{parentName:"p"},"@")," is problematic as it risks a chance of collision with a public npm package and may accidentally\nopen your repository to a\n",(0,o.kt)("a",{parentName:"p",href:"https://snyk.io/blog/npm-security-preventing-supply-chain-attacks/"},"supply chain attack"),". Other\ncharacters like ",(0,o.kt)("inlineCode",{parentName:"p"},"~")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," have an existing meaning in the ecosystem, so it's best to avoid them\naswell.")),(0,o.kt)("h3",{id:"importing-source-files-from-local-packages"},"Importing source files from local packages"),(0,o.kt)("p",null,"If you are importing from a project reference using a ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," name, then TypeScript will\nabide by Node.js module resolution logic, and will import using the\n",(0,o.kt)("a",{parentName:"p",href:"https://nodejs.org/api/packages.html#package-entry-points"},(0,o.kt)("inlineCode",{parentName:"a"},"main"),"/",(0,o.kt)("inlineCode",{parentName:"a"},"types")," or ",(0,o.kt)("inlineCode",{parentName:"a"},"exports")," entry points"),".\nThis means that you're importing ",(0,o.kt)("em",{parentName:"p"},"compiled code")," instead of source code, and will require the\npackage to be constantly rebuilt if changes are made to it."),(0,o.kt)("p",null,"However, why not simply import source files instead? With path aliases, you can do just that, by\ndefining a ",(0,o.kt)("inlineCode",{parentName:"p"},"paths")," alias that maps the ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," name to its source files, like so."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="<project>/tsconfig.json"',title:'"<project>/tsconfig.json"'},'{\n  // ...\n  "compilerOptions": {\n    // ...\n    "paths": {\n      // Index import\n      "@scope/name": ["../../shared/package/src/index.ts"],\n      // Deep imports\n      "@scope/name/*": ["../../shared/package/src/*"]\n    }\n  },\n  "references": [\n    {\n      "path": "../../shared/package"\n    }\n  ]\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"When using moon, the\n",(0,o.kt)("a",{parentName:"p",href:"../../config/toolchain#syncprojectreferencestopaths"},(0,o.kt)("inlineCode",{parentName:"a"},"typescript.syncProjectReferencesToPaths")),"\nsetting will automatically create ",(0,o.kt)("inlineCode",{parentName:"p"},"paths")," based on the local references.")),(0,o.kt)("h2",{id:"sharing-and-augmenting-types"},"Sharing and augmenting types"),(0,o.kt)("p",null,"Declaring global types, augmenting node modules, and sharing reusable types is a common practice.\nThere are many ways to achieve this, so choose what works best for your repository. We use the\nfollowing pattern with great success."),(0,o.kt)("p",null,"At the root of the repository, create a ",(0,o.kt)("inlineCode",{parentName:"p"},"types")," folder as a sibling to ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json"),". This folder\n",(0,o.kt)("em",{parentName:"p"},"must only")," contain declarations (",(0,o.kt)("inlineCode",{parentName:"p"},".d.ts"),") files for the following reasons:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Declarations can be ",(0,o.kt)("inlineCode",{parentName:"li"},"include"),"ed in a project without having to be a project reference."),(0,o.kt)("li",{parentName:"ul"},"Hard-coded declarations ",(0,o.kt)("em",{parentName:"li"},"do not")," need to be compiled from TypeScript files.")),(0,o.kt)("p",null,"Based on the above, update your project's ",(0,o.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," to include all of these types, or just\nsome of these types."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="<project>/tsconfig.json"',title:'"<project>/tsconfig.json"'},'{\n  // ...\n  "include": ["src/**/*", "../../../../types/**/*"]\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"In the future, moon will provide a setting to automate this workflow!")),(0,o.kt)("h2",{id:"supporting-packagejson-exports"},"Supporting ",(0,o.kt)("inlineCode",{parentName:"h2"},"package.json")," exports"),(0,o.kt)("p",null,"In Node.js v12, they introduced a new field to ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," called ",(0,o.kt)("inlineCode",{parentName:"p"},"exports")," that aims to solve\nthe shortcomings of the ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," field. The ",(0,o.kt)("inlineCode",{parentName:"p"},"exports")," field is very complicated, and instead of\nrepeating all of its implementation details, we suggest reading\n",(0,o.kt)("a",{parentName:"p",href:"https://nodejs.org/api/packages.html#package-entry-points"},"the official Node.js docs on this topic"),"."),(0,o.kt)("p",null,"With that being said, TypeScript completely ignored the ",(0,o.kt)("inlineCode",{parentName:"p"},"exports")," field until\n",(0,o.kt)("a",{parentName:"p",href:"https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#esm-nodejs"},"v4.7"),", and\nrespecting ",(0,o.kt)("inlineCode",{parentName:"p"},"exports")," is ",(0,o.kt)("em",{parentName:"p"},"still ignored unless")," the ",(0,o.kt)("inlineCode",{parentName:"p"},"moduleResolution"),' compiler option is set to\n"nodenext" or "node16". If ',(0,o.kt)("inlineCode",{parentName:"p"},"moduleResolution"),' is set to "node", then your integration is resolving\nbased on the ',(0,o.kt)("inlineCode",{parentName:"p"},"main")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"types"),' field, which are basically "legacy".'),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"Enabling ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," imports/exports resolution is very complicated, and may be very tedious,\nespecially considering the state of the npm ecosystem. Proceed with caution!")),(0,o.kt)("h3",{id:"state-of-the-npm-ecosystem"},"State of the npm ecosystem"),(0,o.kt)("p",null,"As mentioned above, the npm ecosystem (as of November 2022) is in a very fragile state in regards to\nimports/exports. Based on our experience attempting to utilize them in a monorepo, we ran into an\narray of problems, some of which are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Published packages are simply utilizing imports/exports incorrectly. The semantics around CJS/ESM\nare very strict, and they may be configured wrong. This is exacerbated by the new ",(0,o.kt)("inlineCode",{parentName:"li"},"type")," field."),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"exports")," field ",(0,o.kt)("em",{parentName:"li"},"overrides")," the ",(0,o.kt)("inlineCode",{parentName:"li"},"main")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"types")," fields. If ",(0,o.kt)("inlineCode",{parentName:"li"},"exports")," exists without type\nconditions, but the ",(0,o.kt)("inlineCode",{parentName:"li"},"types")," field exists, the ",(0,o.kt)("inlineCode",{parentName:"li"},"types")," entry point is completely ignored, resulting\nin TypeScript failures.")),(0,o.kt)("p",null,"With that being said, there are ",(0,o.kt)("a",{parentName:"p",href:"#resolving-issues"},"ways around this")," and moving forward is\npossible, if you dare!"),(0,o.kt)("h3",{id:"enabling-importsexports-resolution"},"Enabling imports/exports resolution"),(0,o.kt)("p",null,"To start, set the ",(0,o.kt)("inlineCode",{parentName:"p"},"moduleResolution"),' compiler option to "nodenext" in the\n',(0,o.kt)("a",{parentName:"p",href:"#tsconfigoptionsjson"},(0,o.kt)("inlineCode",{parentName:"a"},"tsconfig.options.json"))," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'file="tsconfig.options.json"',file:'"tsconfig.options.json"'},'{\n  "compilerOptions": {\n    // ...\n    "moduleResolution": "nodenext"\n  }\n}\n')),(0,o.kt)("p",null,"Next, ",(0,o.kt)("a",{parentName:"p",href:"#on-all-projects"},"run the typechecker from the root")," against all projects. This will help\nuncover all potential issues with the dependencies you're using or the current configuration\narchitecture. If no errors are found, well ",(0,o.kt)("em",{parentName:"p"},"congratulations"),", otherwise jump to the next section for\nmore information on ",(0,o.kt)("a",{parentName:"p",href:"#resolving-issues"},"resolving them"),"."),(0,o.kt)("p",null,"If you're trying to use ",(0,o.kt)("inlineCode",{parentName:"p"},"exports")," in your own packages, ensure that the ",(0,o.kt)("inlineCode",{parentName:"p"},"types")," condition is set,\nand it's the first condition in the mapping! We also suggest including ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," and the top-level\n",(0,o.kt)("inlineCode",{parentName:"p"},"types")," for tooling that do not support ",(0,o.kt)("inlineCode",{parentName:"p"},"exports")," yet."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json"',title:'"package.json"'},'{\n  // ...\n  "main": "./lib/index.js",\n  "types": "./lib/index.d.ts",\n  "exports": {\n    "./package.json": "./package.json",\n    ".": {\n      "types": "./lib/index.d.ts",\n      "node": "./lib/index.js"\n    }\n  }\n}\n')),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Managing ",(0,o.kt)("inlineCode",{parentName:"p"},"exports")," is non-trivial. If you'd prefer them to be automatically generated based on a set\nof inputs, we suggest using ",(0,o.kt)("a",{parentName:"p",href:"https://packemon.dev/"},"Packemon"),"!")),(0,o.kt)("h3",{id:"resolving-issues"},"Resolving issues"),(0,o.kt)("p",null,"There's only one way to resolve issues around incorrectly published ",(0,o.kt)("inlineCode",{parentName:"p"},"exports"),", and that is package\npatching, either with ",(0,o.kt)("a",{parentName:"p",href:"https://yarnpkg.com/features/protocols/#patch"},"Yarn's patching feature"),",\n",(0,o.kt)("a",{parentName:"p",href:"https://pnpm.io/cli/patch"},"pnpm's patching feature"),", or the\n",(0,o.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/patch-package"},(0,o.kt)("inlineCode",{parentName:"a"},"patch-package")," package"),". With patching, you can:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Inject the ",(0,o.kt)("inlineCode",{parentName:"li"},"types")," condition/field if it's missing."),(0,o.kt)("li",{parentName:"ul"},"Re-structure the ",(0,o.kt)("inlineCode",{parentName:"li"},"exports")," mapping if it's incorrect."),(0,o.kt)("li",{parentName:"ul"},"Fix incorrect entry point paths."),(0,o.kt)("li",{parentName:"ul"},"And even fix invalid TypeScript declarations or JavaScript code!")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff",metastring:'title="package.json"',title:'"package.json"'},'{\n  "main": "./lib/index.js",\n  "types": "./lib/index.d.ts",\n  "exports": {\n    "./package.json": "./package.json",\n-    ".": "./lib/index.js"\n+    ".": {\n+      "types": "./lib/index.d.ts",\n+      "node": "./lib/index.js"\n+    }\n  }\n}\n')),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"More often than not, the owners of these packages may be unaware that their ",(0,o.kt)("inlineCode",{parentName:"p"},"exports")," mapping is\nincorrect. Why not be a good member of the community and report an issue or even submit a pull\nrequest?")),(0,o.kt)("h2",{id:"editor-integration"},"Editor integration"),(0,o.kt)("p",null,"Unfortunately, we only have experience with VS Code. If you prefer another editor and have guidance\nyou'd like to share with the community, feel free to submit a pull request and we'll include it\nbelow!"),(0,o.kt)("h3",{id:"vs-code"},"VS Code"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/"},"VS Code"),' has first-class support for TypeScript and project\nreferences, and should "just work" without any configuration. You can verify this by restarting the\nTypeScript server in VS Code (with the ',(0,o.kt)("kbd",null,"cmd + shift + p")," command palette) and navigating to\neach project. Pay attention to the status bar at the bottom, as you'll see this:"),(0,o.kt)(s.Z,{src:n(56386),width:"350px",mdxType:"Image"}),(0,o.kt)("p",null,"When this status appears, it means that VS Code is ",(0,o.kt)("em",{parentName:"p"},"compiling a project"),". It will re-appear multiple\ntimes, basically for each project, instead of once for the entire repository."),(0,o.kt)("p",null,"Furthermore, ensure that VS Code is using the version of TypeScript from the ",(0,o.kt)("inlineCode",{parentName:"p"},"typescript")," package in\n",(0,o.kt)("inlineCode",{parentName:"p"},"node_modules"),". Relying on the version that ships with VS Code may result in unexpected TypeScript\nfailures."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title=".vscode/settings.json"',title:'".vscode/settings.json"'},'{\n  "typescript.tsdk": "node_modules/typescript/lib"\n  // Or "Select TypeScript version" from the command palette\n}\n')),(0,o.kt)("h2",{id:"faq"},"FAQ"),(0,o.kt)("h3",{id:"i-still-have-questions-where-can-i-ask-them"},"I still have questions, where can I ask them?"),(0,o.kt)("p",null,"We'd love to answer your questions and help anyway that we can. Feel free to..."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Join the ",(0,o.kt)("a",{parentName:"li",href:"https://discord.gg/qCh9MEynv2"},"moonrepo discord")," and post your question in the\n",(0,o.kt)("inlineCode",{parentName:"li"},"#typescript")," channel."),(0,o.kt)("li",{parentName:"ul"},"Ping me, ",(0,o.kt)("a",{parentName:"li",href:"https://twitter.com/mileswjohnson"},"Miles Johnson"),", on Twitter. I'll try my best to\nrespond to every tweet.")),(0,o.kt)("h3",{id:"do-i-have-to-use-project-references"},"Do I have to use project references?"),(0,o.kt)("p",null,"Short answer, no. If you have less than say 10 projects, references may be overkill. If your\nrepository is primarily an application, but then has a handful of shared npm packages, references\nmay also be unncessary here. In the end, it really depends on how many projects exist in the\nmonorepo, and what your team/company is comfortable with."),(0,o.kt)("p",null,"However, we do suggest using project references for very large monorepos (think 100s of projects),\nor repositories with a large number of contributors, or if you merely want to reduce CI typechecking\ntimes."),(0,o.kt)("h3",{id:"what-about-not-using-project-references-and-only-using-source-files"},"What about not using project references and only using source files?"),(0,o.kt)("p",null,"A popular alternative to project references is to simply use the source files as-is, by updating the\n",(0,o.kt)("inlineCode",{parentName:"p"},"main")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"types")," entry fields within each ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json"),' to point to the original TypeScript\nfiles. This approach is also known as "internal packages".'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="package.json"',title:'"package.json"'},'{\n  // ...\n  "main": "./src/index.tsx",\n  "types": "./src/index.tsx"\n}\n')),(0,o.kt)("p",null,"While this ",(0,o.kt)("em",{parentName:"p"},"works"),", there are some downsides to this approach."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Loading declaration files are much faster than source files."),(0,o.kt)("li",{parentName:"ul"},"You'll lose all the benefits of TypeScript's incremental caching and compilation. TypeScript will\nconsistently load, parse, and evaluate these source files every time. This is especially true for\nCI environments."),(0,o.kt)("li",{parentName:"ul"},"When using ",(0,o.kt)("inlineCode",{parentName:"li"},"package.json"),' workspaces, bundlers and other tools may consider these source files\n"external" as they\'re found in ',(0,o.kt)("inlineCode",{parentName:"li"},"node_modules"),". This will require custom configuration to allow it."),(0,o.kt)("li",{parentName:"ul"},'It breaks consistency. Consistency with the npm ecosystem, and consistency with how packaging and\nTypeScript was designed to work. If all packages are internal, then great, but if you have some\npackages that are published, you now have 2 distinct patterns for "using packages" instead of 1.')),(0,o.kt)("p",null,"With that being said, theres a 3rd alternative that may be the best of both worlds, using project\nreferences ",(0,o.kt)("em",{parentName:"p"},"and")," source files,\n",(0,o.kt)("a",{parentName:"p",href:"#importing-source-files-from-local-packages"},"by using ",(0,o.kt)("inlineCode",{parentName:"a"},"paths")," aliases"),"."),(0,o.kt)("p",null,"All in all, this is a viable approach if you're comfortable with the downsides listed above. Use the\npattern that works best for your repository, team, or company!"),(0,o.kt)("h3",{id:"how-to-integrate-with-eslint"},"How to integrate with ESLint?"),(0,o.kt)("p",null,"We initially included ESLint integration in this guide, but it was very complex and in-depth on its\nown, so we've opted to push it to another guide. Unfortunately, that guide is not yet available, so\nplease come back soon! We'll announce when it's ready."),(0,o.kt)("h3",{id:"how-to-handle-circular-references"},"How to handle circular references?"),(0,o.kt)("p",null,"Project references ",(0,o.kt)("em",{parentName:"p"},"do ",(0,o.kt)("strong",{parentName:"em"},"not")," support\n",(0,o.kt)("a",{parentName:"em",href:"https://github.com/microsoft/TypeScript/issues/33685"},"circular references"))," (cycles), which is\ngreat, as they are a ",(0,o.kt)("em",{parentName:"p"},"code smell"),'! If you find yourself arbitrarily importing code from random\nsources, or between 2 projects that depend on each other, then this highlights a problem with your\narchitecture. Projects should be encapsulated and isolated from outside sources, unless explicitly\nallowed through a dependency. Dependencies are "upstream", so having them depend on the current\nproject (the "downstream"), makes little to no sense.'),(0,o.kt)("p",null,"If you're trying to adopt project references and are unfortunately hitting the circular reference\nproblem, don't fret, untangling is possible, although non-trivial depending on the size of your\nrepository. It basically boils down to creating an additional project to move coupled code to."),(0,o.kt)("p",null,"For example, if project A was importing from project B, and B from A, then the solution would be to\ncreate another project, C (typically a shared npm package), and move both pieces of code into C. A\nand B would then import from C, instead of from each other. We're not aware of any tools that would\nautomate this, or detect cycles, so you'll need to do it manually."))}h.isMDXComponent=!0},56386:(e,t,n)=>{n.r(t),n.d(t,{default:()=>a});const a=n.p+"assets/images/vscode-status-1c68ec4790b8766b34a5e91cba1231d7.png"}}]);