"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6633],{35318:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(27378);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),c=p(t),m=i,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||o;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,l=new Array(o);l[0]=c;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var p=2;p<o;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},92510:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var a=t(25773),i=(t(27378),t(35318));const o={title:"WASM plugin (experimental)",sidebar_label:"WASM (experimental)",toc_max_heading_level:5},l=void 0,r={unversionedId:"proto/wasm-plugin",id:"proto/wasm-plugin",title:"WASM plugin (experimental)",description:"Plugins can be written in WebAssembly (WASM), a portable binary format.",source:"@site/docs/proto/wasm-plugin.mdx",sourceDirName:"proto",slug:"/proto/wasm-plugin",permalink:"/docs/proto/wasm-plugin",draft:!1,editUrl:"https://github.com/moonrepo/moon/tree/master/website/docs/proto/wasm-plugin.mdx",tags:[],version:"current",frontMatter:{title:"WASM plugin (experimental)",sidebar_label:"WASM (experimental)",toc_max_heading_level:5},sidebar:"proto",previous:{title:"TOML",permalink:"/docs/proto/toml-plugin"},next:{title:"FAQ",permalink:"/docs/proto/faq"}},s={},p=[{value:"Create a plugin",id:"create-a-plugin",level:2},{value:"Registering metadata",id:"registering-metadata",level:3},{value:"Downloading pre-builts",id:"downloading-pre-builts",level:3},{value:"Unpacking an archive",id:"unpacking-an-archive",level:4},{value:"Locating binaries",id:"locating-binaries",level:3},{value:"Loading and resolving versions",id:"loading-and-resolving-versions",level:3},{value:"Detecting versions",id:"detecting-versions",level:3},{value:"Creating shims",id:"creating-shims",level:3},{value:"Global shims",id:"global-shims",level:4},{value:"Testing",id:"testing",level:2},{value:"Unit tests",id:"unit-tests",level:3},{value:"Building and publishing",id:"building-and-publishing",level:2},{value:"Manually create releases",id:"manually-create-releases",level:3},{value:"Automate releases",id:"automate-releases",level:3},{value:"Resources",id:"resources",level:2}],u={toc:p};function d(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Plugins can be written in ",(0,i.kt)("a",{parentName:"p",href:"https://webassembly.org/"},"WebAssembly (WASM)"),", a portable binary format.\nThis means that plugins can be written in any language that compiles to WASM, like Rust, C, C++, Go,\nTypeScript, and more. Because WASM based plugins are powered by a programming language, they\nimplicitly support complex business logic and behavior, have access to a sandboxed file system (via\nWASI), can execute child processes, and much more."),(0,i.kt)("p",null,"However, since WASM executes in its own runtime, it ",(0,i.kt)("em",{parentName:"p"},"does not")," have access to the current host\noperating system, architecture, environment variables, and more. To bridge this gap, we provide this\ninformation as an ",(0,i.kt)("inlineCode",{parentName:"p"},"env")," field for every function input (more below)."),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"Since our WASM plugin implementation is still experimental, expect breaking changes to occur in\nnon-major releases.")),(0,i.kt)("h2",{id:"create-a-plugin"},"Create a plugin"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Although plugins can be written in any language that compiles to WASM, we've only tested Rust. The\nrest of this article assume you're using Rust and Cargo! Refer to ",(0,i.kt)("a",{parentName:"p",href:"https://extism.org/"},"Extism"),"'s\ndocumentation or our official ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/moonrepo/node-plugin"},"Node.js plugin")," for other\nexamples.")),(0,i.kt)("p",null,"To start, create a new crate with Cargo:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cargo new plugin --lib\ncd plugin\n")),(0,i.kt)("p",null,"And set the lib type to ",(0,i.kt)("inlineCode",{parentName:"p"},"cdylib"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-toml",metastring:'title="Cargo.toml"',title:'"Cargo.toml"'},"[lib]\ncrate-type = ['cdylib']\n")),(0,i.kt)("p",null,"Our Rust plugins are powered by ",(0,i.kt)("a",{parentName:"p",href:"https://extism.org/"},"Extism"),", so lets add their PDK and ours as a\ndependency."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cargo add extism-pdk proto_pdk\n")),(0,i.kt)("p",null,"In all Rust files, we can import both PDKs with the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},"use extism_pdk::*;\nuse proto_pdk::*;\n")),(0,i.kt)("p",null,"We can then build the WASM binary. The file will be available at\n",(0,i.kt)("inlineCode",{parentName:"p"},"target/wasm32-wasi/debug/<name>.wasm"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cargo build --target wasm32-wasi\n")),(0,i.kt)("h3",{id:"registering-metadata"},"Registering metadata"),(0,i.kt)("p",null,"The first step in a plugin's life-cycle is to register metadata about the plugin with the\n",(0,i.kt)("inlineCode",{parentName:"p"},"register_tool")," function. This function is called immediately after a plugin is loaded at runtime,\nand must return a human-readable name and plugin type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn register_tool(_: ()) -> FnResult<Json<ToolMetadataOutput>> {\n    Ok(Json(ToolMetadataOutput {\n        name: "Node.js".into(),\n        type_of: PluginType::Language,\n        ..ToolMetadataOutput::default()\n    }))\n}\n')),(0,i.kt)("p",null,"This function also receives the plugin ID as input, allowing for conditional logic based on the ID.\nThe ID is the ",(0,i.kt)("a",{parentName:"p",href:"#enabling-plugins"},"key the plugin was configured with"),", and what is passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"proto"),"\ncommands (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"proto install <id>"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[plugin_fn]\npub fn register_tool(Json(input): Json<ToolMetadataInput>) -> FnResult<Json<ToolMetadataOutput>> {\n  input.id\n  // ...\n}\n")),(0,i.kt)("h3",{id:"downloading-pre-builts"},"Downloading pre-builts"),(0,i.kt)("p",null,"Our plugin layer ",(0,i.kt)("em",{parentName:"p"},"only")," supports downloading pre-built tools, typically as an archive, and does\n",(0,i.kt)("em",{parentName:"p"},"not")," support building from source. The ",(0,i.kt)("inlineCode",{parentName:"p"},"download_prebuilt")," function ",(0,i.kt)("em",{parentName:"p"},"must")," be defined, whichs\nconfigures how the tool should be downloaded and installed."),(0,i.kt)("p",null,"The following fields are available:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"archive_prefix")," - If the tool is distributed as an archive (zip, tar, etc), this is the name of\nthe direct folder within the archive that contains the tool, and will be removed when unpacking\nthe archive. If there is no prefix folder within the archive, this setting can be omitted."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"download_url")," (required) - A secure URL to download the tool/archive."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"download_name")," - File name of the archive to download. If not provided, will attempt to extract\nit from the URL."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"checksum_url")," - A secure URL to download the checksum file for verification. If the tool does not\nsupport checksum verification, this setting can be omitted.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn download_prebuilt(Json(input): Json<DownloadPrebuiltInput>) -> FnResult<Json<DownloadPrebuiltOutput>> {\n    let version = input.env.version;\n    let arch = input.env.arch;\n    let os = input.env.os;\n\n    let prefix = match os {\n        HostOS::Linux => format!("node-v{version}-linux-{arch}"),\n        HostOS::MacOS => format!("node-v{version}-darwin-{arch}"),\n        HostOS::Windows => format!("node-v{version}-win-{arch}"),\n        other => {\n            return Err(PluginError::UnsupportedPlatform("Node.js".into(), other.into()))?;\n        }\n    };\n\n    let filename = if os == HostOS::Windows {\n        format!("{prefix}.zip")\n    } else {\n        format!("{prefix}.tar.xz")\n    };\n\n    Ok(Json(DownloadPrebuiltOutput {\n        archive_prefix: Some(prefix),\n        download_url: format!("https://nodejs.org/dist/v{version}/{filename}"),\n        download_name: Some(filename),\n        checksum_url: Some(format!("https://nodejs.org/dist/v{version}/SHASUMS256.txt")),\n        ..DownloadPrebuiltOutput::default()\n    }))\n}\n')),(0,i.kt)("h4",{id:"unpacking-an-archive"},"Unpacking an archive"),(0,i.kt)("p",null,"Our plugin layer will do its best to detect file extensions, unpack the downloaded file (if an\narchive), and install the tool to the correct directory. However, we're unable to account for ",(0,i.kt)("em",{parentName:"p"},"all"),"\nedge cases, so for situations where the install params above are not sufficient, you may define an\n",(0,i.kt)("inlineCode",{parentName:"p"},"unpack_archive")," function."),(0,i.kt)("p",null,"This function receives an input with the following fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"input_file")," - Virtual path to the downloaded file. Maps to ",(0,i.kt)("inlineCode",{parentName:"li"},"~/.proto/temp/<id>/<file>"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"output_dir")," - Virtual directory to unpack the archive into, or copy the binary to. Maps to\n",(0,i.kt)("inlineCode",{parentName:"li"},"~/.proto/tools/<id>/<version>"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[plugin_fn]\npub fn unpack_archive(Json(input): Json<UnpackArchiveInput>) -> FnResult<()> {\n    untar(input.input_file, input.output_dir)?;\n    Ok(())\n}\n")),(0,i.kt)("h3",{id:"locating-binaries"},"Locating binaries"),(0,i.kt)("p",null,"Even though a tool has been installed, we must inform proto of where to find the binary to execute.\nThis can be achieved with the optional ",(0,i.kt)("inlineCode",{parentName:"p"},"locate_bins")," function. If this function is not defined,\nproto will assume the binary is named ",(0,i.kt)("inlineCode",{parentName:"p"},"<id>")," (",(0,i.kt)("inlineCode",{parentName:"p"},"<id>.exe")," on Windows), relative from the installation\ndirectory."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn locate_bins(Json(input): Json<LocateBinsInput>) -> FnResult<Json<LocateBinsOutput>> {\n    Ok(Json(LocateBinsOutput {\n        bin_path: Some(if input.env.os == HostOS::Windows {\n            "node.exe".into()\n        } else {\n            "bin/node".into()\n        }),\n        ..LocateBinsOutput::default()\n    }))\n}\n')),(0,i.kt)("p",null,"Furthermore, the ",(0,i.kt)("inlineCode",{parentName:"p"},"locate_bins")," function can define a list of lookups for the globals installation\ndirectory. proto will loop through each lookup, and return the first directory that exists on the\ncurrent file system. proto will also expand environment variables in the format of ",(0,i.kt)("inlineCode",{parentName:"p"},"$VAR_NAME"),". If a\nvariable is not defined, or has an empty value, the lookup will be skipped. To demonstrate this,\nwe'll use ",(0,i.kt)("a",{parentName:"p",href:"https://deno.land/manual@v1.35.0/tools/script_installer"},"Deno"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn locate_bins(Json(_): Json<LocateBinsInput>) -> FnResult<Json<LocateBinsOutput>> {\n    Ok(Json(LocateBinsOutput {\n        globals_lookup_dirs: vec!["$DENO_INSTALL_ROOT/bin".into(), "$HOME/.deno/bin".into()],\n        ..LocateBinsOutput::default()\n    }))\n}\n')),(0,i.kt)("h3",{id:"loading-and-resolving-versions"},"Loading and resolving versions"),(0,i.kt)("p",null,"Now that the tool can be downloaded and installed, we must configure how to resolve available\nversions to actually be installed. To provide a list of versions and language specific aliases, the\n",(0,i.kt)("inlineCode",{parentName:"p"},"load_versions")," function must be defined."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn load_versions(Json(_): Json<LoadVersionsInput>) -> FnResult<Json<LoadVersionsOutput>> {\n    let mut output = LoadVersionsOutput::default();\n    let response: Vec<NodeDistVersion> = fetch_url("https://nodejs.org/dist/index.json")?;\n\n    for (index, item) in response.iter().enumerate() {\n        let version = Version::parse(&item.version[1..])?; // Starts with v\n\n        if index == 0 {\n            output.latest = Some(version.clone());\n        }\n\n        output.versions.push(version);\n    }\n\n    Ok(Json(output))\n}\n')),(0,i.kt)("p",null,"Furthermore, we support an optional function named ",(0,i.kt)("inlineCode",{parentName:"p"},"resolve_version"),", that can be defined to\nintercept the version resolution process. This function receives an input with an initial candidate,\neither an alias or version, and can replace it with a new candidate. The candidate must be a valid\nalias or version as defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"load_versions"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn resolve_version(\n    Json(input): Json<ResolveVersionInput>,\n) -> FnResult<Json<ResolveVersionOutput>> {\n    let mut output = ResolveVersionOutput::default();\n\n    if input.initial == "node" {\n        output.candidate = Some("latest".into());\n\n    } else if input.initial == "lts-*" || input.initial == "lts/*" {\n        output.candidate = Some("stable".into());\n\n    } else if input.initial.starts_with("lts-") || input.initial.starts_with("lts/") {\n        output.candidate = Some(input.initial[4..].to_owned());\n    }\n\n    Ok(Json(output))\n}\n')),(0,i.kt)("h3",{id:"detecting-versions"},"Detecting versions"),(0,i.kt)("p",null,"And lastly, we can configure how to ",(0,i.kt)("a",{parentName:"p",href:"./detection"},"detect a version")," contextually at runtime, using\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"detect_version_files")," function and optional ",(0,i.kt)("inlineCode",{parentName:"p"},"parse_version_file")," function. The\n",(0,i.kt)("inlineCode",{parentName:"p"},"detect_version_files")," function can return a list of files to locate within a directory."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn detect_version_files(_: ()) -> FnResult<Json<DetectVersionOutput>> {\n    Ok(Json(DetectVersionOutput {\n        files: vec![\n            ".nvmrc".into(),\n            ".node-version".into(),\n            "package.json".into(),\n        ],\n    }))\n}\n')),(0,i.kt)("p",null,'By default our plugin layer will assume the version file\'s contents contain the literal version, and\nnothing else, like "1.2.3". If any of the files in the ',(0,i.kt)("inlineCode",{parentName:"p"},"detect_version_files")," list require custom\nparsing (for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"package.json")," above), you can define the ",(0,i.kt)("inlineCode",{parentName:"p"},"parse_version_file")," function."),(0,i.kt)("p",null,"This function receives the file name and contents as input, and must return the parsed version (if\napplicable)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn parse_version_file(Json(input): Json<ParseVersionInput>) -> FnResult<Json<ParseVersionOutput>> {\n    let mut version = None;\n\n    if input.file == "package.json" {\n        let json: PackageJson = serde_json::from_str(&input.content)?;\n\n        if let Some(engines) = json.engines {\n            if let Some(constraint) = engines.get("node") {\n                version = Some(constraint.to_owned());\n            }\n        }\n    } else {\n        version = Some(input.content.trim().to_owned());\n    }\n\n    Ok(Json(ParseVersionOutput { version }))\n}\n')),(0,i.kt)("h3",{id:"creating-shims"},"Creating shims"),(0,i.kt)("p",null,"Tools within proto wouldn't function without shims, and as such, plugins can register their own\nshims to be created. By default, proto ",(0,i.kt)("em",{parentName:"p"},"will always")," create a global shim of the plugin at\n",(0,i.kt)("inlineCode",{parentName:"p"},"~/.proto/bin/<id>"),", but you can also register additional shims with the ",(0,i.kt)("inlineCode",{parentName:"p"},"create_shims")," function."),(0,i.kt)("h4",{id:"global-shims"},"Global shims"),(0,i.kt)("p",null,"Global shims are optional scripts that are available on ",(0,i.kt)("inlineCode",{parentName:"p"},"PATH")," as they are generated in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"~/.proto/bin")," directory, and can be defined with the ",(0,i.kt)("inlineCode",{parentName:"p"},"global_shims")," parameter. This param is a hash\nmap, where the key is the shim file name, and the value is a relative path (from the tool's\ndirectory) to a binary to execute."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[plugin_fn]\npub fn create_shims(Json(input): Json<CreateShimsInput>) -> FnResult<Json<CreateShimsOutput>> {\n    let mut global_shims = HashMap::new();\n\n    global_shims.insert("npx".into(), if input.env.os == HostOS::Windows {\n        "npx.cmd".into()\n    } else {\n        "bin/npx".into()\n    });\n\n    Ok(Json(CreateShimsOutput {\n        global_shims,\n        ..CreateShimsOutput::default()\n    }))\n}\n')),(0,i.kt)("h2",{id:"testing"},"Testing"),(0,i.kt)("p",null,"The best way to test the plugin is to execute it through ",(0,i.kt)("inlineCode",{parentName:"p"},"proto")," directly. To do this, you'll need\nto configure a ",(0,i.kt)("inlineCode",{parentName:"p"},".prototools")," file at the root of your plugin's repository that maps the plugin to a\ndebug build:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-toml"},'[plugins]\n<id> = "source:target/wasm32-wasi/debug/<name>.wasm"\n')),(0,i.kt)("p",null,"And everytime you make a change to the plugin, you'll need to rebuild it with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cargo build --target wasm32-wasi\n")),(0,i.kt)("p",null,"With these 2 pieces in place, you can now execute ",(0,i.kt)("inlineCode",{parentName:"p"},"proto")," commands. Be sure you're running them from\nthe directory with the ",(0,i.kt)("inlineCode",{parentName:"p"},".prototools")," file, and that you're passing ",(0,i.kt)("inlineCode",{parentName:"p"},"--log trace"),". Logs are extremely\nhelpful for figuring out what's going on."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"proto --log trace install <id>\nproto --log trace list-remote <id>\n...\n")),(0,i.kt)("h3",{id:"unit-tests"},"Unit tests"),(0,i.kt)("p",null,"Coming soon..."),(0,i.kt)("h2",{id:"building-and-publishing"},"Building and publishing"),(0,i.kt)("p",null,"At this point, you should have a fully working WASM plugin, but to make it available to downstream\nproto users, you'll still need to build and make the ",(0,i.kt)("inlineCode",{parentName:"p"},".wasm")," file available. The easiest solution is\nto publish a GitHub release and include the ",(0,i.kt)("inlineCode",{parentName:"p"},".wasm")," file as an asset."),(0,i.kt)("h3",{id:"manually-create-releases"},"Manually create releases"),(0,i.kt)("p",null,"When your plugin is ready to be published, you can create a release on GitHub using the following\nsteps."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Tag the release and push to GitHub.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"git tag v0.0.1\ngit push --tags\n")),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Build a release version of the plugin. The file will be available at\n",(0,i.kt)("inlineCode",{parentName:"li"},"target/wasm32-wasi/release/<name>.wasm"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"cargo build --target wasm32-wasi --release\n")),(0,i.kt)("ol",{start:3},(0,i.kt)("li",{parentName:"ol"},"In GitHub, navigate to the tags page, find the new tag, create a new release, and attach the\nbuilt file as an asset.")),(0,i.kt)("h3",{id:"automate-releases"},"Automate releases"),(0,i.kt)("p",null,"Coming soon!"),(0,i.kt)("h2",{id:"resources"},"Resources"),(0,i.kt)("p",null,"Some helpful resources for learning about and building plugins."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Official proto WASM plugins",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/moonrepo/node-plugin"},"Node.js, npm, etc")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.rs/proto_pdk/"},"Documentation for ",(0,i.kt)("inlineCode",{parentName:"a"},"proto_pdk")," (plugin development kit)"))))}d.isMDXComponent=!0}}]);